# Agendas

## Future topics

### Functions & Execution Context

### How to approach algorithms

* Listen, example, brute force, optimize, walk through, implement, test
* Big O notation
  * runtime -- time & space complexity
  * For example, Nested for-loops: _Is there simpler solution?_
  * Encourage use of benchmarking
  * Space complexity uses RAM -- Recursion a solution or problem?

### ES2017 stuff

* e.g merge sort
* Data structures
  * Map, BST (these are helpful structures for common algorithms)
  * Bit manipulation/bitwise operators
  * Hash table, return number appearing an odd number of times

### Static vs dynamic typing

### Testing answers

* Creating simple tests, creating automated unit tests
* Thinking in character codes
	* Often helpful to convert characters to their code value
	* Unicode vs. ASCII

### Borrowing ideas from Java, Python, C++, JS

* e.g. in Java, often you create arrays with a certain length. This is helpful for some algorithms, but not an approach one might consider in JS (find first dupe).

### Pro Pseudocode

* Importance of pseudocode (importance of it when asked to do it)
* Don't write comments to describe code, write code to describe comments

### Version Control

* Git → Adam wants to do Coders’ Workshop repo
  * Reset head, revert

### Asynchronous

### Multiple pointers

* reverse array in place, etc

### Using RegEx

* can be very helpful for coders outside of solving algorithms, e.g. refactoring code
* can also make quick work of some algorithms, e.g. Andy's solution to parens problem

### Algorithms/problems

* Sort into easy, medium, hard, expert
* Ideally have a few skill levels for each topic
